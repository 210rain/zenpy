######################################################################
#  Do not modify, these classes are autogenerated by gen_classes.py  #
######################################################################

import dateutil.parser


class BaseObject(object):
    def to_dict(self):
        copy_dict = self.__dict__.copy()
        for key in list(copy_dict.keys()):
            if copy_dict[key] is None or key == 'api':
                del copy_dict[key]
                continue

            if key.startswith('_'):
                copy_dict[key[1:]] = copy_dict[key]
                del copy_dict[key]
        return copy_dict

    def __repr__(self):
        if hasattr(self, 'id'):
            return "[%s(id=%s)]" % (self.__class__.__name__, self.id)
        elif hasattr(self, 'token'):
            return "[%s(token='%s')]" % (self.__class__.__name__, self.token)
        else:
            return "[%s()]" % self.__class__.__name__


class NotificationEvent(BaseObject):
    def __init__(self, api=None, body=None, id=None, subject=None, type=None, **kwargs):

        self.api = api

        self._recipients = None

        self._via = None
        self.body = body
        self.id = id
        self.subject = subject
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def recipients(self):

        if self.api and self._recipients:
            return self.api._get_users(self._recipients)

    @recipients.setter
    def recipients(self, recipients):
        if recipients:
            self._recipients = recipients

    @property
    def via(self):

        if self.api and self._via:
            return self.api._get_via(self._via)

    @via.setter
    def via(self, via):
        if via:
            self._via = via


class Forum(BaseObject):
    def __init__(self, api=None, access=None, category_id=None, created_at=None, description=None, forum_type=None,
                 id=None, locale_id=None, locked=None, name=None, organization_id=None, position=None, tags=None,
                 updated_at=None, url=None, **kwargs):

        self.api = api
        self.access = access
        self.category_id = category_id
        self.created_at = created_at
        self.description = description
        self.forum_type = forum_type
        self.id = id
        self.locale_id = locale_id
        self.locked = locked
        self.name = name
        self.organization_id = organization_id
        self.position = position
        self.tags = tags
        self.updated_at = updated_at
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def category(self):

        if self.api and self.category_id:
            return self.api._get_category(self.category_id)

    @category.setter
    def category(self, category):
        if category:
            self.category_id = category.id
            self._category = category

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def organization(self):

        if self.api and self.organization_id:
            return self.api._get_organization(self.organization_id)

    @organization.setter
    def organization(self, organization):
        if organization:
            self.organization_id = organization.id
            self._organization = organization

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class Tag(BaseObject):
    def __init__(self, api=None, count=None, name=None, **kwargs):
        self.api = api
        self.count = count
        self.name = name

        for key, value in kwargs.items():
            setattr(self, key, value)


class TicketField(BaseObject):
    def __init__(self, api=None, active=None, collapsed_for_agents=None, created_at=None, description=None,
                 editable_in_portal=None, id=None, position=None, raw_description=None, raw_title=None,
                 raw_title_in_portal=None, regexp_for_validation=None, required=None, required_in_portal=None, tag=None,
                 title=None, title_in_portal=None, type=None, updated_at=None, url=None, visible_in_portal=None,
                 **kwargs):

        self.api = api

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Whether this field is available
        self.active = active

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: If this field should be shown to agents by default or be hidden alongside infrequently used fields. Classic interface only
        self.collapsed_for_agents = collapsed_for_agents

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time the ticket field was created
        self.created_at = created_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The description of the purpose of this ticket field, shown to users
        self.description = description

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Whether this field is editable by end users
        self.editable_in_portal = editable_in_portal

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Automatically assigned upon creation
        self.id = id

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: A relative position for the ticket fields, determines the order of ticket fields on a ticket
        self.position = position

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The dynamic content placeholder, if present, or the "description" value, if not. See Dynamic Content
        self.raw_description = raw_description

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The dynamic content placeholder, if present, or the "title" value, if not. See Dynamic Content
        self.raw_title = raw_title

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The dynamic content placeholder, if present, or the "title_in_portal" value, if not. See Dynamic Content
        self.raw_title_in_portal = raw_title_in_portal

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Regular expression field only. The validation pattern for a field value to be deemed valid.
        self.regexp_for_validation = regexp_for_validation

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: If it's required for this field to have a value when updated by agents
        self.required = required

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: If it's required for this field to have a value when updated by end users
        self.required_in_portal = required_in_portal

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: A tag value to set for checkbox fields when checked
        self.tag = tag

        #:| Type: string
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: The title of the ticket field
        self.title = title

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The title of the ticket field when shown to end users
        self.title_in_portal = title_in_portal

        #:| Type: string
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: The type of the ticket field: "checkbox", "date", "decimal", "integer", "regexp", "tagger", "text", or "textarea"
        self.type = type

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time of the last update of the ticket field
        self.updated_at = updated_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The URL for this resource
        self.url = url

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Whether this field is available to end users
        self.visible_in_portal = visible_in_portal

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):
        """
        |  Type: date
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class TweetEvent(BaseObject):
    def __init__(self, api=None, body=None, direct_message=None, id=None, type=None, **kwargs):

        self.api = api

        self._recipients = None
        self.body = body
        self.direct_message = direct_message
        self.id = id
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def recipients(self):

        if self.api and self._recipients:
            return self.api._get_users(self._recipients)

    @recipients.setter
    def recipients(self, recipients):
        if recipients:
            self._recipients = recipients


class TicketMetric(BaseObject):
    def __init__(self, api=None, assigned_at=None, assignee_stations=None, assignee_updated_at=None, created_at=None,
                 group_stations=None, id=None, initially_assigned_at=None, latest_comment_added_at=None, reopens=None,
                 replies=None, requester_updated_at=None, solved_at=None, status_updated_at=None, ticket_id=None,
                 updated_at=None, **kwargs):

        self.api = api

        #:| Type: object
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Number of minutes the agent spent waiting inside and out of business hours

        self._agent_wait_time_in_minutes = None

        #:| Type: object
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Number of minutes to the first resolution time inside and out of business hours

        self._first_resolution_time_in_minutes = None

        #:| Type: object
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Number of minutes to the full resolution inside and out of business hours

        self._full_resolution_time_in_minutes = None

        self._on_hold_time_in_minutes = None

        #:| Type: object
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Number of minutes to the first reply inside and out of business hours

        self._reply_time_in_minutes = None

        #:| Type: object
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Number of minutes the requester spent waiting inside and out of business hours

        self._requester_wait_time_in_minutes = None

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When the ticket was last assigned
        self.assigned_at = assigned_at

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Number of assignees this ticket had
        self.assignee_stations = assignee_stations

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When the assignee last updated the ticket
        self.assignee_updated_at = assignee_updated_at

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When this record was created
        self.created_at = created_at

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Number of groups this ticket passed through
        self.group_stations = group_stations

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Automatically assigned
        self.id = id

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When the ticket was initially assigned
        self.initially_assigned_at = initially_assigned_at

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When the latest comment was added
        self.latest_comment_added_at = latest_comment_added_at

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Total number of times the ticket was reopened
        self.reopens = reopens

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Total number of times ticket was replied to
        self.replies = replies

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When the requester last updated the ticket
        self.requester_updated_at = requester_updated_at

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When the ticket was solved
        self.solved_at = solved_at

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When the status was last updated
        self.status_updated_at = status_updated_at

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Id of the associated ticket
        self.ticket_id = ticket_id

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When this record last got updated
        self.updated_at = updated_at

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def agent_wait_time_in_minutes(self):
        """
        |  Type: object
        """
        if self.api and self._agent_wait_time_in_minutes:
            return self.api._get_ticket_metric_item(self._agent_wait_time_in_minutes)

    @agent_wait_time_in_minutes.setter
    def agent_wait_time_in_minutes(self, agent_wait_time_in_minutes):
        if agent_wait_time_in_minutes:
            self._agent_wait_time_in_minutes = agent_wait_time_in_minutes

    @property
    def first_resolution_time_in_minutes(self):
        """
        |  Type: object
        """
        if self.api and self._first_resolution_time_in_minutes:
            return self.api._get_ticket_metric_item(self._first_resolution_time_in_minutes)

    @first_resolution_time_in_minutes.setter
    def first_resolution_time_in_minutes(self, first_resolution_time_in_minutes):
        if first_resolution_time_in_minutes:
            self._first_resolution_time_in_minutes = first_resolution_time_in_minutes

    @property
    def full_resolution_time_in_minutes(self):
        """
        |  Type: object
        """
        if self.api and self._full_resolution_time_in_minutes:
            return self.api._get_ticket_metric_item(self._full_resolution_time_in_minutes)

    @full_resolution_time_in_minutes.setter
    def full_resolution_time_in_minutes(self, full_resolution_time_in_minutes):
        if full_resolution_time_in_minutes:
            self._full_resolution_time_in_minutes = full_resolution_time_in_minutes

    @property
    def on_hold_time_in_minutes(self):

        if self.api and self._on_hold_time_in_minutes:
            return self.api._get_ticket_metric_item(self._on_hold_time_in_minutes)

    @on_hold_time_in_minutes.setter
    def on_hold_time_in_minutes(self, on_hold_time_in_minutes):
        if on_hold_time_in_minutes:
            self._on_hold_time_in_minutes = on_hold_time_in_minutes

    @property
    def reply_time_in_minutes(self):
        """
        |  Type: object
        """
        if self.api and self._reply_time_in_minutes:
            return self.api._get_ticket_metric_item(self._reply_time_in_minutes)

    @reply_time_in_minutes.setter
    def reply_time_in_minutes(self, reply_time_in_minutes):
        if reply_time_in_minutes:
            self._reply_time_in_minutes = reply_time_in_minutes

    @property
    def requester_wait_time_in_minutes(self):
        """
        |  Type: object
        """
        if self.api and self._requester_wait_time_in_minutes:
            return self.api._get_ticket_metric_item(self._requester_wait_time_in_minutes)

    @requester_wait_time_in_minutes.setter
    def requester_wait_time_in_minutes(self, requester_wait_time_in_minutes):
        if requester_wait_time_in_minutes:
            self._requester_wait_time_in_minutes = requester_wait_time_in_minutes

    @property
    def assigned(self):
        """
        |  Type: date
        """
        if self.assigned_at:
            return dateutil.parser.parse(self.assigned_at)

    @assigned.setter
    def assigned(self, assigned):
        if assigned:
            self.assigned_at = assigned

    @property
    def assignee_updated(self):
        """
        |  Type: date
        """
        if self.assignee_updated_at:
            return dateutil.parser.parse(self.assignee_updated_at)

    @assignee_updated.setter
    def assignee_updated(self, assignee_updated):
        if assignee_updated:
            self.assignee_updated_at = assignee_updated

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def initially_assigned(self):
        """
        |  Type: date
        """
        if self.initially_assigned_at:
            return dateutil.parser.parse(self.initially_assigned_at)

    @initially_assigned.setter
    def initially_assigned(self, initially_assigned):
        if initially_assigned:
            self.initially_assigned_at = initially_assigned

    @property
    def latest_comment_added(self):
        """
        |  Type: date
        """
        if self.latest_comment_added_at:
            return dateutil.parser.parse(self.latest_comment_added_at)

    @latest_comment_added.setter
    def latest_comment_added(self, latest_comment_added):
        if latest_comment_added:
            self.latest_comment_added_at = latest_comment_added

    @property
    def requester_updated(self):
        """
        |  Type: date
        """
        if self.requester_updated_at:
            return dateutil.parser.parse(self.requester_updated_at)

    @requester_updated.setter
    def requester_updated(self, requester_updated):
        if requester_updated:
            self.requester_updated_at = requester_updated

    @property
    def solved(self):
        """
        |  Type: date
        """
        if self.solved_at:
            return dateutil.parser.parse(self.solved_at)

    @solved.setter
    def solved(self, solved):
        if solved:
            self.solved_at = solved

    @property
    def status_updated(self):
        """
        |  Type: date
        """
        if self.status_updated_at:
            return dateutil.parser.parse(self.status_updated_at)

    @status_updated.setter
    def status_updated(self, status_updated):
        if status_updated:
            self.status_updated_at = status_updated

    @property
    def ticket(self):
        """
        |  Type: integer
        """
        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)

    @ticket.setter
    def ticket(self, ticket):
        if ticket:
            self.ticket_id = ticket.id
            self._ticket = ticket

    @property
    def updated(self):
        """
        |  Type: date
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class System(BaseObject):
    def __init__(self, api=None, client=None, ip_address=None, latitude=None, location=None, longitude=None, **kwargs):
        self.api = api
        self.client = client
        self.ip_address = ip_address
        self.latitude = latitude
        self.location = location
        self.longitude = longitude

        for key, value in kwargs.items():
            setattr(self, key, value)


class OrganizationField(BaseObject):
    def __init__(self, api=None, active=None, created_at=None, description=None, id=None, key=None, position=None,
                 raw_description=None, raw_title=None, regexp_for_validation=None, title=None, type=None,
                 updated_at=None, url=None, **kwargs):

        self.api = api

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: If true, this field is available for use
        self.active = active

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time the ticket field was created
        self.created_at = created_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: User-defined description of this field's purpose
        self.description = description

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Automatically assigned upon creation
        self.id = id

        #:| Type: string
        #:| Mandatory: on create
        #:| Read-only: no
        #:| Comment: A unique key that identifies this custom field. This is used for updating the field and referencing in placeholders.
        self.key = key

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Ordering of the field relative to other fields
        self.position = position

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The dynamic content placeholder, if present, or the "description" value, if not. See Dynamic Content
        self.raw_description = raw_description

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The dynamic content placeholder, if present, or the "title" value, if not. See Dynamic Content
        self.raw_title = raw_title

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Regular expression field only. The validation pattern for a field value to be deemed valid.
        self.regexp_for_validation = regexp_for_validation

        #:| Type: string
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: The title of the custom field
        self.title = title

        #:| Type: string
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: Type of the custom field: "checkbox", "date", "decimal", "dropdown", "integer", "regexp", "text", or "textarea"
        self.type = type

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time of the last update of the ticket field
        self.updated_at = updated_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The URL for this resource
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):
        """
        |  Type: date
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class UserRelated(BaseObject):
    def __init__(self, api=None, assigned_tickets=None, ccd_tickets=None, entry_subscriptions=None,
                 forum_subscriptions=None, organization_subscriptions=None, requested_tickets=None, subscriptions=None,
                 topic_comments=None, topics=None, votes=None, **kwargs):
        self.api = api
        self.assigned_tickets = assigned_tickets
        self.ccd_tickets = ccd_tickets
        self.entry_subscriptions = entry_subscriptions
        self.forum_subscriptions = forum_subscriptions
        self.organization_subscriptions = organization_subscriptions
        self.requested_tickets = requested_tickets
        self.subscriptions = subscriptions
        self.topic_comments = topic_comments
        self.topics = topics
        self.votes = votes

        for key, value in kwargs.items():
            setattr(self, key, value)


class TicketEvent(BaseObject):
    def __init__(self, api=None, id=None, ticket_id=None, timestamp=None, updater_id=None, via=None, **kwargs):

        self.api = api

        self._child_events = None
        self.id = id
        self.ticket_id = ticket_id
        self.timestamp = timestamp
        self.updater_id = updater_id
        self.via = via

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def child_events(self):

        if self.api and self._child_events:
            return self.api._get_child_events(self._child_events)

    @child_events.setter
    def child_events(self, child_events):
        if child_events:
            self._child_events = child_events

    @property
    def ticket(self):

        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)

    @ticket.setter
    def ticket(self, ticket):
        if ticket:
            self.ticket_id = ticket.id
            self._ticket = ticket

    @property
    def updater(self):

        if self.api and self.updater_id:
            return self.api._get_user(self.updater_id)

    @updater.setter
    def updater(self, updater):
        if updater:
            self.updater_id = updater.id
            self._updater = updater


class VoiceCommentEvent(BaseObject):
    def __init__(self, api=None, author_id=None, body=None, formatted_from=None, formatted_to=None, html_body=None,
                 id=None, public=None, transcription_visible=None, trusted=None, type=None, **kwargs):

        self.api = api

        self._attachments = None

        self._data = None
        self.author_id = author_id
        self.body = body
        self.formatted_from = formatted_from
        self.formatted_to = formatted_to
        self.html_body = html_body
        self.id = id
        self.public = public
        self.transcription_visible = transcription_visible
        self.trusted = trusted
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def attachments(self):

        if self.api and self._attachments:
            return self.api._get_attachments(self._attachments)

    @attachments.setter
    def attachments(self, attachments):
        if attachments:
            self._attachments = attachments

    @property
    def data(self):

        if self.api and self._data:
            return self.api._get_data(self._data)

    @data.setter
    def data(self, data):
        if data:
            self._data = data

    @property
    def author(self):

        if self.api and self.author_id:
            return self.api._get_user(self.author_id)

    @author.setter
    def author(self, author):
        if author:
            self.author_id = author.id
            self._author = author


class Request(BaseObject):
    def __init__(self, api=None, assignee_id=None, can_be_solved_by_me=None, collaborator_ids=None, created_at=None,
                 description=None, due_at=None, id=None, organization_id=None, priority=None, requester_id=None,
                 status=None, subject=None, type=None, updated_at=None, url=None, **kwargs):

        self.api = api

        #:| Type: :class:`Array`
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The fields and entries for this request

        self._custom_fields = None

        self._fields = None

        #:| Type: :class:`Via`
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: This object explains how the request was created

        self._via = None

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The id of the assignee if the field is visible to end users
        self.assignee_id = assignee_id

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: If true, end user can mark request as solved.
        self.can_be_solved_by_me = can_be_solved_by_me

        #:| Type: array
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Who are currently CC'ed on the ticket
        self.collaborator_ids = collaborator_ids

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When this record was created
        self.created_at = created_at

        #:| Type: string
        #:| Mandatory: yes
        #:| Read-only: yes
        #:| Comment: The first comment on the request
        self.description = description

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: When the task is due (only applies if the request is of type "task")
        self.due_at = due_at

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Automatically assigned when creating requests
        self.id = id

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The organization of the requester
        self.organization_id = organization_id

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The priority of the request, "low", "normal", "high", "urgent"
        self.priority = priority

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The id of the requester
        self.requester_id = requester_id

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The state of the request, "new", "open", "pending", "hold", "solved", "closed"
        self.status = status

        #:| Type: string
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: The value of the subject field for this request if the subject field is visible to end users; a truncated version of the description otherwise
        self.subject = subject

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The type of the request, "question", "incident", "problem", "task"
        self.type = type

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When this record last got updated
        self.updated_at = updated_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The API url of this request
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def custom_fields(self):
        """
        |  Type: :class:`Array`
        """
        if self.api and self._custom_fields:
            return self.api._get_custom_fields(self._custom_fields)

    @custom_fields.setter
    def custom_fields(self, custom_fields):
        if custom_fields:
            self._custom_fields = custom_fields

    @property
    def fields(self):

        if self.api and self._fields:
            return self.api._get_fields(self._fields)

    @fields.setter
    def fields(self, fields):
        if fields:
            self._fields = fields

    @property
    def via(self):
        """
        |  Type: :class:`Via`
        """
        if self.api and self._via:
            return self.api._get_via(self._via)

    @via.setter
    def via(self, via):
        if via:
            self._via = via

    @property
    def assignee(self):
        """
        |  Type: integer
        """
        if self.api and self.assignee_id:
            return self.api._get_user(self.assignee_id)

    @assignee.setter
    def assignee(self, assignee):
        if assignee:
            self.assignee_id = assignee.id
            self._assignee = assignee

    @property
    def collaborators(self):
        """
        |  Type: array
        """
        if self.api and self.collaborator_ids:
            return self.api._get_users(self.collaborator_ids)

    @collaborators.setter
    def collaborators(self, collaborators):
        if collaborators:
            self.collaborator_ids = [o.id for o in collaborators]
            self._collaborators = collaborators

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def due(self):
        """
        |  Type: date
        """
        if self.due_at:
            return dateutil.parser.parse(self.due_at)

    @due.setter
    def due(self, due):
        if due:
            self.due_at = due

    @property
    def organization(self):
        """
        |  Type: integer
        """
        if self.api and self.organization_id:
            return self.api._get_organization(self.organization_id)

    @organization.setter
    def organization(self, organization):
        if organization:
            self.organization_id = organization.id
            self._organization = organization

    @property
    def requester(self):
        """
        |  Type: integer
        """
        if self.api and self.requester_id:
            return self.api._get_user(self.requester_id)

    @requester.setter
    def requester(self, requester):
        if requester:
            self.requester_id = requester.id
            self._requester = requester

    @property
    def updated(self):
        """
        |  Type: date
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class UserField(BaseObject):
    def __init__(self, api=None, active=None, created_at=None, description=None, id=None, key=None, position=None,
                 raw_description=None, raw_title=None, regexp_for_validation=None, title=None, type=None,
                 updated_at=None, url=None, **kwargs):

        self.api = api

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: If true, this field is available for use
        self.active = active

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time the ticket field was created
        self.created_at = created_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: User-defined description of this field's purpose
        self.description = description

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Automatically assigned upon creation
        self.id = id

        #:| Type: string
        #:| Mandatory: on create
        #:| Read-only: no
        #:| Comment: A unique key that identifies this custom field. This is used for updating the field and referencing in placeholders.
        self.key = key

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Ordering of the field relative to other fields
        self.position = position

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The dynamic content placeholder, if present, or the "description" value, if not. See Dynamic Content
        self.raw_description = raw_description

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The dynamic content placeholder, if present, or the "title" value, if not. See Dynamic Content
        self.raw_title = raw_title

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Regular expression field only. The validation pattern for a field value to be deemed valid.
        self.regexp_for_validation = regexp_for_validation

        #:| Type: string
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: The title of the custom field
        self.title = title

        #:| Type: string
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: Type of the custom field: "checkbox", "date", "decimal", "dropdown", "integer", "regexp", "text", or "textarea"
        self.type = type

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time of the last update of the ticket field
        self.updated_at = updated_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The URL for this resource
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):
        """
        |  Type: date
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class Metadata(BaseObject):
    def __init__(self, api=None, **kwargs):

        self.api = api

        self._custom = None

        self._system = None

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def custom(self):

        if self.api and self._custom:
            return self.api._get_custom(self._custom)

    @custom.setter
    def custom(self, custom):
        if custom:
            self._custom = custom

    @property
    def system(self):

        if self.api and self._system:
            return self.api._get_system(self._system)

    @system.setter
    def system(self, system):
        if system:
            self._system = system


class Topic(BaseObject):
    def __init__(self, api=None, body=None, created_at=None, forum_id=None, id=None, locked=None, pinned=None,
                 position=None, submitter_id=None, tags=None, title=None, topic_type=None, updated_at=None,
                 updater_id=None, url=None, **kwargs):

        self.api = api

        self._search_phrases = None
        self.body = body
        self.created_at = created_at
        self.forum_id = forum_id
        self.id = id
        self.locked = locked
        self.pinned = pinned
        self.position = position
        self.submitter_id = submitter_id
        self.tags = tags
        self.title = title
        self.topic_type = topic_type
        self.updated_at = updated_at
        self.updater_id = updater_id
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def search_phrases(self):

        if self.api and self._search_phrases:
            return self.api._get_search_phrases(self._search_phrases)

    @search_phrases.setter
    def search_phrases(self, search_phrases):
        if search_phrases:
            self._search_phrases = search_phrases

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def forum(self):

        if self.api and self.forum_id:
            return self.api._get_forum(self.forum_id)

    @forum.setter
    def forum(self, forum):
        if forum:
            self.forum_id = forum.id
            self._forum = forum

    @property
    def submitter(self):

        if self.api and self.submitter_id:
            return self.api._get_user(self.submitter_id)

    @submitter.setter
    def submitter(self, submitter):
        if submitter:
            self.submitter_id = submitter.id
            self._submitter = submitter

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated

    @property
    def updater(self):

        if self.api and self.updater_id:
            return self.api._get_user(self.updater_id)

    @updater.setter
    def updater(self, updater):
        if updater:
            self.updater_id = updater.id
            self._updater = updater


class Activity(BaseObject):
    def __init__(self, api=None, actor=None, created_at=None, id=None, title=None, updated_at=None, url=None, user=None,
                 verb=None, **kwargs):

        self.api = api
        self.actor = actor
        self.created_at = created_at
        self.id = id
        self.title = title
        self.updated_at = updated_at
        self.url = url
        self.user = user
        self.verb = verb

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):

        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class Status(BaseObject):
    def __init__(self, api=None, action=None, errors=None, id=None, status=None, success=None, title=None, **kwargs):
        self.api = api
        self.action = action
        self.errors = errors
        self.id = id
        self.status = status
        self.success = success
        self.title = title

        for key, value in kwargs.items():
            setattr(self, key, value)


class TicketSharingEvent(BaseObject):
    def __init__(self, api=None, action=None, agreement_id=None, id=None, type=None, **kwargs):

        self.api = api
        self.action = action
        self.agreement_id = agreement_id
        self.id = id
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def agreement(self):

        if self.api and self.agreement_id:
            return self.api._get_agreement(self.agreement_id)

    @agreement.setter
    def agreement(self, agreement):
        if agreement:
            self.agreement_id = agreement.id
            self._agreement = agreement


class PushEvent(BaseObject):
    def __init__(self, api=None, id=None, type=None, value=None, value_reference=None, **kwargs):
        self.api = api
        self.id = id
        self.type = type
        self.value = value
        self.value_reference = value_reference

        for key, value in kwargs.items():
            setattr(self, key, value)


class ErrorEvent(BaseObject):
    def __init__(self, api=None, id=None, message=None, type=None, **kwargs):
        self.api = api
        self.id = id
        self.message = message
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)


class LogmeinTranscriptEvent(BaseObject):
    def __init__(self, api=None, body=None, id=None, type=None, **kwargs):
        self.api = api
        self.body = body
        self.id = id
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)


class OrganizationActivityEvent(BaseObject):
    def __init__(self, api=None, body=None, id=None, subject=None, type=None, **kwargs):

        self.api = api

        self._recipients = None

        self._via = None
        self.body = body
        self.id = id
        self.subject = subject
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def recipients(self):

        if self.api and self._recipients:
            return self.api._get_users(self._recipients)

    @recipients.setter
    def recipients(self, recipients):
        if recipients:
            self._recipients = recipients

    @property
    def via(self):

        if self.api and self._via:
            return self.api._get_via(self._via)

    @via.setter
    def via(self, via):
        if via:
            self._via = via


class TicketAudit(BaseObject):
    def __init__(self, api=None, audit=None, ticket=None, **kwargs):
        self.api = api
        self.audit = audit
        self.ticket = ticket

        for key, value in kwargs.items():
            setattr(self, key, value)


class Upload(BaseObject):
    def __init__(self, api=None, expires_at=None, token=None, **kwargs):

        self.api = api

        self._attachment = None

        self._attachments = None
        self.expires_at = expires_at
        self.token = token

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def attachment(self):

        if self.api and self._attachment:
            return self.api._get_attachment(self._attachment)

    @attachment.setter
    def attachment(self, attachment):
        if attachment:
            self._attachment = attachment

    @property
    def attachments(self):

        if self.api and self._attachments:
            return self.api._get_attachments(self._attachments)

    @attachments.setter
    def attachments(self, attachments):
        if attachments:
            self._attachments = attachments

    @property
    def expires(self):

        if self.expires_at:
            return dateutil.parser.parse(self.expires_at)

    @expires.setter
    def expires(self, expires):
        if expires:
            self.expires_at = expires


class User(BaseObject):
    def __init__(self, api=None, active=None, alias=None, chat_only=None, created_at=None, custom_role_id=None,
                 details=None, email=None, external_id=None, id=None, last_login_at=None, locale=None, locale_id=None,
                 moderator=None, name=None, notes=None, only_private_comments=None, organization_id=None, phone=None,
                 photo=None, restricted_agent=None, role=None, shared=None, shared_agent=None, signature=None,
                 suspended=None, tags=None, ticket_restriction=None, time_zone=None, two_factor_auth_enabled=None,
                 updated_at=None, url=None, verified=None, **kwargs):

        self.api = api

        #:| Type: :class:`hash`
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Custom fields for the user

        self._user_fields = None

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: false if the user has been deleted
        self.active = active

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: An alias displayed to end users
        self.alias = alias

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Whether or not the user is a chat-only agent
        self.chat_only = chat_only

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time the user was created
        self.created_at = created_at

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: A custom role if the user is an agent on the Enterprise plan
        self.custom_role_id = custom_role_id

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Any details you want to store about the user, such as an address
        self.details = details

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The user's primary email address
        self.email = email

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: A unique id you can specify for the user
        self.external_id = external_id

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Automatically assigned when the user is created
        self.id = id

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The last time the user signed in to Zendesk Support
        self.last_login_at = last_login_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The user's locale
        self.locale = locale

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The user's language identifier
        self.locale_id = locale_id

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Designates whether the user has forum moderation capabilities
        self.moderator = moderator

        #:| Type: string
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: The user's name
        self.name = name

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Any notes you want to store about the user
        self.notes = notes

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: true if the user can only create private comments
        self.only_private_comments = only_private_comments

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The id of the organization the user is associated with
        self.organization_id = organization_id

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The user's primary phone number. See Phone Number below
        self.phone = phone

        #:| Type: :class:`Attachment`
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The user's profile picture represented as an Attachment object
        self.photo = photo

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: If the agent has any restrictions; false for admins and unrestricted agents, true for other agents
        self.restricted_agent = restricted_agent

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The user's role. Possible values are "end-user", "agent", or "admin"
        self.role = role

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: If the user is shared from a different Zendesk Support instance. Ticket sharing accounts only
        self.shared = shared

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: If the user is a shared agent from a different Zendesk Support instance. Ticket sharing accounts only
        self.shared_agent = shared_agent

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The user's signature. Only agents and admins can have signatures
        self.signature = signature

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: If the agent is suspended. Tickets from suspended users are also suspended, and these users cannot sign in to the end user portal
        self.suspended = suspended

        #:| Type: array
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The user's tags. Only present if your account has user tagging enabled
        self.tags = tags

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Specifies which tickets the user has access to. Possible values are: "organization", "groups", "assigned", "requested", null
        self.ticket_restriction = ticket_restriction

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The user's time zone. See Time Zone below
        self.time_zone = time_zone

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: If two factor authentication is enabled.
        self.two_factor_auth_enabled = two_factor_auth_enabled

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time the user was last updated
        self.updated_at = updated_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The user's API url
        self.url = url

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: If the user's identity has been verified or not
        self.verified = verified

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def user_fields(self):
        """
        |  Type: :class:`hash`
        """
        if self.api and self._user_fields:
            return self.api._get_user_fields(self._user_fields)

    @user_fields.setter
    def user_fields(self, user_fields):
        if user_fields:
            self._user_fields = user_fields

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def custom_role(self):
        """
        |  Type: integer
        """
        if self.api and self.custom_role_id:
            return self.api._get_custom_role(self.custom_role_id)

    @custom_role.setter
    def custom_role(self, custom_role):
        if custom_role:
            self.custom_role_id = custom_role.id
            self._custom_role = custom_role

    @property
    def last_login(self):
        """
        |  Type: date
        """
        if self.last_login_at:
            return dateutil.parser.parse(self.last_login_at)

    @last_login.setter
    def last_login(self, last_login):
        if last_login:
            self.last_login_at = last_login

    @property
    def organization(self):
        """
        |  Type: integer
        """
        if self.api and self.organization_id:
            return self.api._get_organization(self.organization_id)

    @organization.setter
    def organization(self, organization):
        if organization:
            self.organization_id = organization.id
            self._organization = organization

    @property
    def updated(self):
        """
        |  Type: date
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class FacebookCommentEvent(BaseObject):
    def __init__(self, api=None, author_id=None, body=None, graph_object_id=None, html_body=None, id=None, public=None,
                 trusted=None, type=None, **kwargs):

        self.api = api

        self._attachments = None

        self._data = None
        self.author_id = author_id
        self.body = body
        self.graph_object_id = graph_object_id
        self.html_body = html_body
        self.id = id
        self.public = public
        self.trusted = trusted
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def attachments(self):

        if self.api and self._attachments:
            return self.api._get_attachments(self._attachments)

    @attachments.setter
    def attachments(self, attachments):
        if attachments:
            self._attachments = attachments

    @property
    def data(self):

        if self.api and self._data:
            return self.api._get_data(self._data)

    @data.setter
    def data(self, data):
        if data:
            self._data = data

    @property
    def author(self):

        if self.api and self.author_id:
            return self.api._get_user(self.author_id)

    @author.setter
    def author(self, author):
        if author:
            self.author_id = author.id
            self._author = author


class SatisfactionRating(BaseObject):
    def __init__(self, api=None, assignee_id=None, created_at=None, group_id=None, id=None, requester_id=None,
                 score=None, ticket_id=None, updated_at=None, url=None, **kwargs):

        self.api = api

        #:| Type: integer
        #:| Mandatory: yes
        #:| Read-only: yes
        #:| Comment: The id of agent assigned to at the time of rating
        self.assignee_id = assignee_id

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time the satisfaction rating got created
        self.created_at = created_at

        #:| Type: integer
        #:| Mandatory: yes
        #:| Read-only: yes
        #:| Comment: The id of group assigned to at the time of rating
        self.group_id = group_id

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Automatically assigned upon creation
        self.id = id

        #:| Type: integer
        #:| Mandatory: yes
        #:| Read-only: yes
        #:| Comment: The id of ticket requester submitting the rating
        self.requester_id = requester_id

        #:| Type: string
        #:| Mandatory: yes
        #:| Read-only: yes
        #:| Comment: The rating: "offered", "unoffered", "good" or "bad"
        self.score = score

        #:| Type: integer
        #:| Mandatory: yes
        #:| Read-only: yes
        #:| Comment: The id of ticket being rated
        self.ticket_id = ticket_id

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time the satisfaction rating got updated
        self.updated_at = updated_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The API url of this rating
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def assignee(self):
        """
        |  Type: integer
        """
        if self.api and self.assignee_id:
            return self.api._get_user(self.assignee_id)

    @assignee.setter
    def assignee(self, assignee):
        if assignee:
            self.assignee_id = assignee.id
            self._assignee = assignee

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def group(self):
        """
        |  Type: integer
        """
        if self.api and self.group_id:
            return self.api._get_group(self.group_id)

    @group.setter
    def group(self, group):
        if group:
            self.group_id = group.id
            self._group = group

    @property
    def requester(self):
        """
        |  Type: integer
        """
        if self.api and self.requester_id:
            return self.api._get_user(self.requester_id)

    @requester.setter
    def requester(self, requester):
        if requester:
            self.requester_id = requester.id
            self._requester = requester

    @property
    def ticket(self):
        """
        |  Type: integer
        """
        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)

    @ticket.setter
    def ticket(self, ticket):
        if ticket:
            self.ticket_id = ticket.id
            self._ticket = ticket

    @property
    def updated(self):
        """
        |  Type: date
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class SatisfactionRatingEvent(BaseObject):
    def __init__(self, api=None, assignee_id=None, body=None, id=None, score=None, type=None, **kwargs):

        self.api = api
        self.assignee_id = assignee_id
        self.body = body
        self.id = id
        self.score = score
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def assignee(self):

        if self.api and self.assignee_id:
            return self.api._get_user(self.assignee_id)

    @assignee.setter
    def assignee(self, assignee):
        if assignee:
            self.assignee_id = assignee.id
            self._assignee = assignee


class Comment(BaseObject):
    def __init__(self, api=None, author_id=None, body=None, created_at=None, id=None, public=None, type=None, **kwargs):

        self.api = api

        self._attachments = None

        self._metadata = None

        self._via = None
        self.author_id = author_id
        self.body = body
        self.created_at = created_at
        self.id = id
        self.public = public
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def attachments(self):

        if self.api and self._attachments:
            return self.api._get_attachments(self._attachments)

    @attachments.setter
    def attachments(self, attachments):
        if attachments:
            self._attachments = attachments

    @property
    def metadata(self):

        if self.api and self._metadata:
            return self.api._get_metadata(self._metadata)

    @metadata.setter
    def metadata(self, metadata):
        if metadata:
            self._metadata = metadata

    @property
    def via(self):

        if self.api and self._via:
            return self.api._get_via(self._via)

    @via.setter
    def via(self, via):
        if via:
            self._via = via

    @property
    def author(self):

        if self.api and self.author_id:
            return self.api._get_user(self.author_id)

    @author.setter
    def author(self, author):
        if author:
            self.author_id = author.id
            self._author = author

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created


class Source(BaseObject):
    def __init__(self, api=None, rel=None, **kwargs):

        self.api = api

        self._from_ = None

        self._to = None
        self.rel = rel

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def from_(self):

        if self.api and self._from_:
            return self.api._get_from_(self._from_)

    @from_.setter
    def from_(self, from_):
        if from_:
            self._from_ = from_


class ExternalEvent(BaseObject):
    def __init__(self, api=None, body=None, id=None, resource=None, type=None, **kwargs):
        self.api = api
        self.body = body
        self.id = id
        self.resource = resource
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)


class Group(BaseObject):
    def __init__(self, api=None, created_at=None, deleted=None, id=None, name=None, updated_at=None, url=None,
                 **kwargs):

        self.api = api

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time the group was created
        self.created_at = created_at

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Deleted groups get marked as such
        self.deleted = deleted

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Automatically assigned when creating groups
        self.id = id

        #:| Type: string
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: The name of the group
        self.name = name

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time of the last update of the group
        self.updated_at = updated_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The API url of this group
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):
        """
        |  Type: date
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class SharingAgreement(BaseObject):
    def __init__(self, api=None, created_at=None, id=None, name=None, partner_name=None, remote_subdomain=None,
                 status=None, type=None, **kwargs):

        self.api = api

        #:| Type: date
        #:| Comment: The time the record was created
        self.created_at = created_at

        #:| Type: integer
        #:| Comment: Automatically assigned upon creation
        self.id = id

        #:| Type: string
        #:| Comment: Name of this sharing agreement
        self.name = name

        #:| Type: string
        #:| Comment: Can be one of the following: 'jira', null
        self.partner_name = partner_name

        #:| Type: string
        #:| Comment: Subdomain of the remote account or null if not associated with an account
        self.remote_subdomain = remote_subdomain

        #:| Type: string
        #:| Comment: Can be one of the following: 'accepted', 'declined', 'pending', 'inactive'
        self.status = status

        #:| Type: string
        #:| Comment: Can be one of the following: 'inbound', 'outbound'
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created


class CommentPrivacyChangeEvent(BaseObject):
    def __init__(self, api=None, comment_id=None, id=None, public=None, type=None, **kwargs):

        self.api = api
        self.comment_id = comment_id
        self.id = id
        self.public = public
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def comment(self):

        if self.api and self.comment_id:
            return self.api._get_comment(self.comment_id)

    @comment.setter
    def comment(self, comment):
        if comment:
            self.comment_id = comment.id
            self._comment = comment


class GroupMembership(BaseObject):
    def __init__(self, api=None, created_at=None, default=None, group_id=None, id=None, updated_at=None, url=None,
                 user_id=None, **kwargs):

        self.api = api

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time the membership was created
        self.created_at = created_at

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: If true, tickets assigned directly to the agent will assume this membership's group.
        self.default = default

        #:| Type: integer
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: The id of a group
        self.group_id = group_id

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Automatically assigned upon creation
        self.id = id

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time of the last update of the membership
        self.updated_at = updated_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The API url of this record
        self.url = url

        #:| Type: integer
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: The id of an agent
        self.user_id = user_id

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def group(self):
        """
        |  Type: integer
        """
        if self.api and self.group_id:
            return self.api._get_group(self.group_id)

    @group.setter
    def group(self, group):
        if group:
            self.group_id = group.id
            self._group = group

    @property
    def updated(self):
        """
        |  Type: date
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated

    @property
    def user(self):
        """
        |  Type: integer
        """
        if self.api and self.user_id:
            return self.api._get_user(self.user_id)

    @user.setter
    def user(self, user):
        if user:
            self.user_id = user.id
            self._user = user


class OrganizationMembership(BaseObject):
    def __init__(self, api=None, created_at=None, default=None, id=None, organization_id=None, updated_at=None,
                 url=None, user_id=None, **kwargs):

        self.api = api

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When this record was created
        self.created_at = created_at

        #:| Type: boolean
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: Denotes whether this is the default organization membership for the user
        self.default = default

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Automatically assigned when creating memberships
        self.id = id

        #:| Type: integer
        #:| Mandatory: yes
        #:| Read-only: yes
        #:| Comment: The ID of the organization associated with this user, in this membership
        self.organization_id = organization_id

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When this record last got updated
        self.updated_at = updated_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The API url of this membership
        self.url = url

        #:| Type: integer
        #:| Mandatory: yes
        #:| Read-only: yes
        #:| Comment: The ID of the user for whom this memberships belongs
        self.user_id = user_id

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def organization(self):
        """
        |  Type: integer
        """
        if self.api and self.organization_id:
            return self.api._get_organization(self.organization_id)

    @organization.setter
    def organization(self, organization):
        if organization:
            self.organization_id = organization.id
            self._organization = organization

    @property
    def updated(self):
        """
        |  Type: date
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated

    @property
    def user(self):
        """
        |  Type: integer
        """
        if self.api and self.user_id:
            return self.api._get_user(self.user_id)

    @user.setter
    def user(self, user):
        if user:
            self.user_id = user.id
            self._user = user


class CreateEvent(BaseObject):
    def __init__(self, api=None, field_name=None, id=None, type=None, value=None, **kwargs):
        self.api = api
        self.field_name = field_name
        self.id = id
        self.type = type
        self.value = value

        for key, value in kwargs.items():
            setattr(self, key, value)


class TicketMetricItem(BaseObject):
    def __init__(self, api=None, business=None, calendar=None, **kwargs):
        self.api = api
        self.business = business
        self.calendar = calendar

        for key, value in kwargs.items():
            setattr(self, key, value)


class FacebookEvent(BaseObject):
    def __init__(self, api=None, body=None, communication=None, id=None, ticket_via=None, type=None, **kwargs):

        self.api = api

        self._page = None
        self.body = body
        self.communication = communication
        self.id = id
        self.ticket_via = ticket_via
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def page(self):

        if self.api and self._page:
            return self.api._get_page(self._page)

    @page.setter
    def page(self, page):
        if page:
            self._page = page


class Brand(BaseObject):
    def __init__(self, api=None, active=None, brand_url=None, created_at=None, default=None, has_help_center=None,
                 help_center_state=None, host_mapping=None, id=None, name=None, subdomain=None, updated_at=None,
                 url=None, **kwargs):

        self.api = api

        #:| Type: :class:`Attachment`
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Logo image for this brand

        self._logo = None

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: If the brand is set as active
        self.active = active

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The url of the brand
        self.brand_url = brand_url

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time the brand was created
        self.created_at = created_at

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Is the brand the default brand for this account
        self.default = default

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: If the brand has a Help Center
        self.has_help_center = has_help_center

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The state of the Help Center: enabled, disabled, or restricted
        self.help_center_state = help_center_state

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The hostmapping to this brand, if any (only admins view this key)
        self.host_mapping = host_mapping

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Automatically assigned when the brand is created
        self.id = id

        #:| Type: string
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: The name of the brand
        self.name = name

        #:| Type: string
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: The subdomain of the brand (only admins view this key)
        self.subdomain = subdomain

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time of the last update of the brand
        self.updated_at = updated_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The API url of this brand
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def logo(self):
        """
        |  Type: :class:`Attachment`
        """
        if self.api and self._logo:
            return self.api._get_logo(self._logo)

    @logo.setter
    def logo(self, logo):
        if logo:
            self._logo = logo

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def updated(self):
        """
        |  Type: date
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class Audit(BaseObject):
    def __init__(self, api=None, author_id=None, created_at=None, id=None, ticket_id=None, **kwargs):

        self.api = api

        self._events = None

        self._metadata = None

        self._via = None
        self.author_id = author_id
        self.created_at = created_at
        self.id = id
        self.ticket_id = ticket_id

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def events(self):

        if self.api and self._events:
            return self.api._get_events(self._events)

    @events.setter
    def events(self, events):
        if events:
            self._events = events

    @property
    def metadata(self):

        if self.api and self._metadata:
            return self.api._get_metadata(self._metadata)

    @metadata.setter
    def metadata(self, metadata):
        if metadata:
            self._metadata = metadata

    @property
    def via(self):

        if self.api and self._via:
            return self.api._get_via(self._via)

    @via.setter
    def via(self, via):
        if via:
            self._via = via

    @property
    def author(self):

        if self.api and self.author_id:
            return self.api._get_user(self.author_id)

    @author.setter
    def author(self, author):
        if author:
            self.author_id = author.id
            self._author = author

    @property
    def created(self):

        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def ticket(self):

        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)

    @ticket.setter
    def ticket(self, ticket):
        if ticket:
            self.ticket_id = ticket.id
            self._ticket = ticket


class Thumbnail(BaseObject):
    def __init__(self, api=None, content_type=None, content_url=None, file_name=None, id=None, size=None, **kwargs):
        self.api = api
        self.content_type = content_type
        self.content_url = content_url
        self.file_name = file_name
        self.id = id
        self.size = size

        for key, value in kwargs.items():
            setattr(self, key, value)


class Attachment(BaseObject):
    def __init__(self, api=None, content_type=None, content_url=None, file_name=None, id=None, size=None, **kwargs):

        self.api = api

        #:| Type: array
        #:| Read-only: yes
        #:| Comment: An array of Photo objects. Note that thumbnails do not have thumbnails.

        self._thumbnails = None

        #:| Type: string
        #:| Read-only: yes
        #:| Comment: The content type of the image. Example value: image/png
        self.content_type = content_type

        #:| Type: string
        #:| Read-only: yes
        #:| Comment: A full URL where the attachment image file can be downloaded
        self.content_url = content_url

        #:| Type: string
        #:| Read-only: yes
        #:| Comment: The name of the image file
        self.file_name = file_name

        #:| Type: integer
        #:| Read-only: yes
        #:| Comment: Automatically assigned when created
        self.id = id

        #:| Type: integer
        #:| Read-only: yes
        #:| Comment: The size of the image file in bytes
        self.size = size

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def thumbnails(self):
        """
        |  Type: array
        """
        if self.api and self._thumbnails:
            return self.api._get_thumbnails(self._thumbnails)

    @thumbnails.setter
    def thumbnails(self, thumbnails):
        if thumbnails:
            self._thumbnails = thumbnails


class SuspendedTicket(BaseObject):
    def __init__(self, api=None, brand_id=None, cause=None, content=None, created_at=None, id=None, recipient=None,
                 subject=None, ticket_id=None, updated_at=None, url=None, **kwargs):

        self.api = api

        #:| Type: object
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The author id (if available), name and email

        self._author = None

        #:| Type: :class:`Via`
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: This object explains how the ticket was created

        self._via = None

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The id of the brand this ticket is associated with - only applicable for enterprise accounts
        self.brand_id = brand_id

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Why the ticket was suspended
        self.cause = cause

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The content that was flagged
        self.content = content

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When this record was created
        self.created_at = created_at

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Automatically assigned
        self.id = id

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The original recipient e-mail address of the ticket
        self.recipient = recipient

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The value of the subject field for this ticket
        self.subject = subject

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The ticket ID this suspended email is associated with, if available
        self.ticket_id = ticket_id

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When this record last got updated
        self.updated_at = updated_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The API url of this ticket
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def via(self):
        """
        |  Type: :class:`Via`
        """
        if self.api and self._via:
            return self.api._get_via(self._via)

    @via.setter
    def via(self, via):
        if via:
            self._via = via

    @property
    def brand(self):
        """
        |  Type: integer
        """
        if self.api and self.brand_id:
            return self.api._get_brand(self.brand_id)

    @brand.setter
    def brand(self, brand):
        if brand:
            self.brand_id = brand.id
            self._brand = brand

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def ticket(self):
        """
        |  Type: integer
        """
        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)

    @ticket.setter
    def ticket(self, ticket):
        if ticket:
            self.ticket_id = ticket.id
            self._ticket = ticket

    @property
    def updated(self):
        """
        |  Type: date
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class ChangeEvent(BaseObject):
    def __init__(self, api=None, field_name=None, id=None, previous_value=None, type=None, value=None, **kwargs):
        self.api = api
        self.field_name = field_name
        self.id = id
        self.previous_value = previous_value
        self.type = type
        self.value = value

        for key, value in kwargs.items():
            setattr(self, key, value)


class JobStatus(BaseObject):
    def __init__(self, api=None, id=None, message=None, progress=None, results=None, status=None, total=None, url=None,
                 **kwargs):
        self.api = api
        self.id = id
        self.message = message
        self.progress = progress
        self.results = results
        self.status = status
        self.total = total
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)


class CcEvent(BaseObject):
    def __init__(self, api=None, id=None, type=None, **kwargs):

        self.api = api

        self._recipients = None

        self._via = None
        self.id = id
        self.type = type

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def recipients(self):

        if self.api and self._recipients:
            return self.api._get_users(self._recipients)

    @recipients.setter
    def recipients(self, recipients):
        if recipients:
            self._recipients = recipients

    @property
    def via(self):

        if self.api and self._via:
            return self.api._get_via(self._via)

    @via.setter
    def via(self, via):
        if via:
            self._via = via


class CustomField(BaseObject):
    def __init__(self, api=None, id=None, value=None, **kwargs):
        self.api = api
        self.id = id
        self.value = value

        for key, value in kwargs.items():
            setattr(self, key, value)


class Organization(BaseObject):
    def __init__(self, api=None, created_at=None, details=None, external_id=None, group_id=None, id=None, name=None,
                 notes=None, shared_comments=None, shared_tickets=None, tags=None, updated_at=None, url=None, **kwargs):

        self.api = api

        #:| Type: array
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: An array of domain names associated with this organization

        self._domain_names = None

        #:| Type: :class:`hash`
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Custom fields for this organization

        self._organization_fields = None

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time the organization was created
        self.created_at = created_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Any details obout the organization, such as the address
        self.details = details

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: A unique external id to associate organizations to an external record
        self.external_id = external_id

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: New tickets from users in this organization are automatically put in this group
        self.group_id = group_id

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Automatically assigned when the organization is created
        self.id = id

        #:| Type: string
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: A unique name for the organization
        self.name = name

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Any notes you have about the organization
        self.notes = notes

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: End users in this organization are able to see each other's comments on tickets
        self.shared_comments = shared_comments

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: End users in this organization are able to see each other's tickets
        self.shared_tickets = shared_tickets

        #:| Type: array
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The tags of the organization
        self.tags = tags

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The time of the last update of the organization
        self.updated_at = updated_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The API url of this organization
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def organization_fields(self):
        """
        |  Type: :class:`hash`
        """
        if self.api and self._organization_fields:
            return self.api._get_organization_fields(self._organization_fields)

    @organization_fields.setter
    def organization_fields(self, organization_fields):
        if organization_fields:
            self._organization_fields = organization_fields

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def group(self):
        """
        |  Type: integer
        """
        if self.api and self.group_id:
            return self.api._get_group(self.group_id)

    @group.setter
    def group(self, group):
        if group:
            self.group_id = group.id
            self._group = group

    @property
    def updated(self):
        """
        |  Type: date
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class Ticket(BaseObject):
    def __init__(self, api=None, assignee_id=None, brand_id=None, collaborator_ids=None, created_at=None,
                 description=None, due_at=None, external_id=None, forum_topic_id=None, group_id=None,
                 has_incidents=None, id=None, organization_id=None, priority=None, problem_id=None, raw_subject=None,
                 recipient=None, requester_id=None, sharing_agreement_ids=None, status=None, subject=None,
                 submitter_id=None, tags=None, type=None, updated_at=None, url=None, **kwargs):

        self.api = api

        #:| Type: array
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The custom fields of the ticket

        self._custom_fields = None

        self._fields = None

        #:| Type: object
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The satisfaction rating of the ticket, if it exists, or the state of satisfaction, 'offered' or 'unoffered'

        self._satisfaction_rating = None

        #:| Type: :class:`Via`
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: This object explains how the ticket was created

        self._via = None

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: What agent is currently assigned to the ticket
        self.assignee_id = assignee_id

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The id of the brand this ticket is associated with - only applicable for enterprise accounts
        self.brand_id = brand_id

        #:| Type: array
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Who are currently CC'ed on the ticket
        self.collaborator_ids = collaborator_ids

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When this record was created
        self.created_at = created_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The first comment on the ticket
        self.description = description

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: If this is a ticket of type "task" it has a due date.  Due date format uses ISO 8601 format.
        self.due_at = due_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: An id you can use to link Zendesk Support tickets to local records
        self.external_id = external_id

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The topic this ticket originated from, if any
        self.forum_topic_id = forum_topic_id

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The group this ticket is assigned to
        self.group_id = group_id

        #:| Type: boolean
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Is true of this ticket has been marked as a problem, false otherwise
        self.has_incidents = has_incidents

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: Automatically assigned when creating tickets
        self.id = id

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: no*
        #:| Comment: The organization of the requester. *Writable only when creating, not when updating
        self.organization_id = organization_id

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: Priority, defines the urgency with which the ticket should be addressed: "urgent", "high", "normal", "low"
        self.priority = priority

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The problem this incident is linked to, if any
        self.problem_id = problem_id

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The dynamic content placeholder, if present, or the "subject" value, if not. See Dynamic Content
        self.raw_subject = raw_subject

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The original recipient e-mail address of the ticket
        self.recipient = recipient

        #:| Type: integer
        #:| Mandatory: yes
        #:| Read-only: no
        #:| Comment: The user who requested this ticket
        self.requester_id = requester_id

        #:| Type: array
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The ids of the sharing agreements used for this ticket
        self.sharing_agreement_ids = sharing_agreement_ids

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The state of the ticket, "new", "open", "pending", "hold", "solved", "closed"
        self.status = status

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The value of the subject field for this ticket
        self.subject = subject

        #:| Type: integer
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The user who submitted the ticket; The submitter always becomes the author of the first comment on the ticket.
        self.submitter_id = submitter_id

        #:| Type: array
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The array of tags applied to this ticket
        self.tags = tags

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: no
        #:| Comment: The type of this ticket, i.e. "problem", "incident", "question" or "task"
        self.type = type

        #:| Type: date
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: When this record last got updated
        self.updated_at = updated_at

        #:| Type: string
        #:| Mandatory: no
        #:| Read-only: yes
        #:| Comment: The API url of this ticket
        self.url = url

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def custom_fields(self):
        """
        |  Type: array
        """
        if self.api and self._custom_fields:
            return self.api._get_custom_fields(self._custom_fields)

    @custom_fields.setter
    def custom_fields(self, custom_fields):
        if custom_fields:
            self._custom_fields = custom_fields

    @property
    def fields(self):

        if self.api and self._fields:
            return self.api._get_fields(self._fields)

    @fields.setter
    def fields(self, fields):
        if fields:
            self._fields = fields

    @property
    def satisfaction_rating(self):
        """
        |  Type: object
        """
        if self.api and self._satisfaction_rating:
            return self.api._get_satisfaction_rating(self._satisfaction_rating)

    @satisfaction_rating.setter
    def satisfaction_rating(self, satisfaction_rating):
        if satisfaction_rating:
            self._satisfaction_rating = satisfaction_rating

    @property
    def via(self):
        """
        |  Type: :class:`Via`
        """
        if self.api and self._via:
            return self.api._get_via(self._via)

    @via.setter
    def via(self, via):
        if via:
            self._via = via

    @property
    def assignee(self):
        """
        |  Type: integer
        """
        if self.api and self.assignee_id:
            return self.api._get_user(self.assignee_id)

    @assignee.setter
    def assignee(self, assignee):
        if assignee:
            self.assignee_id = assignee.id
            self._assignee = assignee

    @property
    def brand(self):
        """
        |  Type: integer
        """
        if self.api and self.brand_id:
            return self.api._get_brand(self.brand_id)

    @brand.setter
    def brand(self, brand):
        if brand:
            self.brand_id = brand.id
            self._brand = brand

    @property
    def collaborators(self):
        """
        |  Type: array
        """
        if self.api and self.collaborator_ids:
            return self.api._get_users(self.collaborator_ids)

    @collaborators.setter
    def collaborators(self, collaborators):
        if collaborators:
            self.collaborator_ids = [o.id for o in collaborators]
            self._collaborators = collaborators

    @property
    def created(self):
        """
        |  Type: date
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)

    @created.setter
    def created(self, created):
        if created:
            self.created_at = created

    @property
    def due(self):
        """
        |  Type: date
        """
        if self.due_at:
            return dateutil.parser.parse(self.due_at)

    @due.setter
    def due(self, due):
        if due:
            self.due_at = due

    @property
    def forum_topic(self):
        """
        |  Type: integer
        """
        if self.api and self.forum_topic_id:
            return self.api._get_topic(self.forum_topic_id)

    @forum_topic.setter
    def forum_topic(self, forum_topic):
        if forum_topic:
            self.forum_topic_id = forum_topic.id
            self._forum_topic = forum_topic

    @property
    def group(self):
        """
        |  Type: integer
        """
        if self.api and self.group_id:
            return self.api._get_group(self.group_id)

    @group.setter
    def group(self, group):
        if group:
            self.group_id = group.id
            self._group = group

    @property
    def organization(self):
        """
        |  Type: integer
        """
        if self.api and self.organization_id:
            return self.api._get_organization(self.organization_id)

    @organization.setter
    def organization(self, organization):
        if organization:
            self.organization_id = organization.id
            self._organization = organization

    @property
    def problem(self):
        """
        |  Type: integer
        """
        if self.api and self.problem_id:
            return self.api._get_problem(self.problem_id)

    @problem.setter
    def problem(self, problem):
        if problem:
            self.problem_id = problem.id
            self._problem = problem

    @property
    def requester(self):
        """
        |  Type: integer
        """
        if self.api and self.requester_id:
            return self.api._get_user(self.requester_id)

    @requester.setter
    def requester(self, requester):
        if requester:
            self.requester_id = requester.id
            self._requester = requester

    @property
    def sharing_agreements(self):
        """
        |  Type: array
        """
        if self.api and self.sharing_agreement_ids:
            return self.api._get_sharing_agreements(self.sharing_agreement_ids)

    @sharing_agreements.setter
    def sharing_agreements(self, sharing_agreements):
        if sharing_agreements:
            self.sharing_agreement_ids = [o.id for o in sharing_agreements]
            self._sharing_agreements = sharing_agreements

    @property
    def submitter(self):
        """
        |  Type: integer
        """
        if self.api and self.submitter_id:
            return self.api._get_user(self.submitter_id)

    @submitter.setter
    def submitter(self, submitter):
        if submitter:
            self.submitter_id = submitter.id
            self._submitter = submitter

    @property
    def updated(self):
        """
        |  Type: date
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)

    @updated.setter
    def updated(self, updated):
        if updated:
            self.updated_at = updated


class Via(BaseObject):
    def __init__(self, api=None, **kwargs):

        self.api = api

        self._source = None

        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def source(self):

        if self.api and self._source:
            return self.api._get_source(self._source)

    @source.setter
    def source(self, source):
        if source:
            self._source = source
